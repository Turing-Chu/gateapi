/*
 * Gate API v4
 *
 * APIv4 provides spot, margin and futures trading operations. There are public APIs to retrieve the real-time market statistics, and private APIs which needs authentication to trade on user's behalf.
 *
 * Contact: support@mail.gate.io
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package gateapi

import (
	"context"
	"errors"
	"fmt"
	"github.com/antihax/optional"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type FuturesApiService service

/*
FuturesApiService Cancel a single order
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param orderId ID returned on order successfully being created
@return FuturesOrder
*/
func (a *FuturesApiService) CancelFuturesOrder(ctx context.Context, settle string, orderId string) (FuturesOrder, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Delete")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FuturesOrder
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/orders/{order_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", fmt.Sprintf("%v", orderId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v FuturesOrder
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService Cancel all `open` orders matched
Zero-fill order cannot be retrieved 60 seconds after cancellation
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param contract Futures contract
 * @param optional nil or *CancelFuturesOrdersOpts - Optional Parameters:
 * @param "Side" (optional.String) -  All bids or asks. Both included in not specified
@return []FuturesOrder
*/

type CancelFuturesOrdersOpts struct {
	Side optional.String
}

func (a *FuturesApiService) CancelFuturesOrders(ctx context.Context, settle string, contract string, localVarOptionals *CancelFuturesOrdersOpts) ([]FuturesOrder, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Delete")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []FuturesOrder
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/orders"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("contract", parameterToString(contract, ""))
	if localVarOptionals != nil && localVarOptionals.Side.IsSet() {
		localVarQueryParams.Add("side", parameterToString(localVarOptionals.Side.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []FuturesOrder
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService Cancel a single order
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param orderId ID returned on order successfully being created
@return FuturesPriceTriggeredOrder
*/
func (a *FuturesApiService) CancelPriceTriggeredOrder(ctx context.Context, settle string, orderId string) (FuturesPriceTriggeredOrder, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Delete")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FuturesPriceTriggeredOrder
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/price_orders/{order_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", fmt.Sprintf("%v", orderId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v FuturesPriceTriggeredOrder
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService Cancel all open orders
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param contract Futures contract
@return []FuturesPriceTriggeredOrder
*/
func (a *FuturesApiService) CancelPriceTriggeredOrderList(ctx context.Context, settle string, contract string) ([]FuturesPriceTriggeredOrder, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Delete")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []FuturesPriceTriggeredOrder
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/price_orders"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("contract", parameterToString(contract, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []FuturesPriceTriggeredOrder
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService Create a futures order
Zero-fill order cannot be retrieved 60 seconds after cancellation
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param futuresOrder
@return FuturesOrder
*/
func (a *FuturesApiService) CreateFuturesOrder(ctx context.Context, settle string, futuresOrder FuturesOrder) (FuturesOrder, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FuturesOrder
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/orders"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &futuresOrder
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v FuturesOrder
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService Create a price-triggered order
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param futuresPriceTriggeredOrder
@return TriggerOrderResponse
*/
func (a *FuturesApiService) CreatePriceTriggeredOrder(ctx context.Context, settle string, futuresPriceTriggeredOrder FuturesPriceTriggeredOrder) (TriggerOrderResponse, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TriggerOrderResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/price_orders"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &futuresPriceTriggeredOrder
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v TriggerOrderResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService Get a single contract
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param contract Futures contract
@return Contract
*/
func (a *FuturesApiService) GetFuturesContract(ctx context.Context, settle string, contract string) (Contract, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Contract
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/contracts/{contract}"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contract"+"}", fmt.Sprintf("%v", contract), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Contract
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService Get a single order
Zero-fill order cannot be retrieved 60 seconds after cancellation
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param orderId ID returned on order successfully being created
@return FuturesOrder
*/
func (a *FuturesApiService) GetFuturesOrder(ctx context.Context, settle string, orderId string) (FuturesOrder, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FuturesOrder
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/orders/{order_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", fmt.Sprintf("%v", orderId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v FuturesOrder
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService List personal trading history
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param optional nil or *GetMyTradesOpts - Optional Parameters:
 * @param "Contract" (optional.String) -  Futures contract, return related data only if specified
 * @param "Order" (optional.Int32) -  Futures order ID, return related data only if specified
 * @param "Limit" (optional.Int32) -  Maximum number of record returned in one list
 * @param "Offset" (optional.Int32) -  List offset, starting from 0
 * @param "LastId" (optional.String) -  Specify list staring point using the `id` of last record in previous list-query results
 * @param "CountTotal" (optional.Int32) -  Whether to return total number matched. Default to 0(no return)
@return []MyFuturesTrade
*/

type GetMyTradesOpts struct {
	Contract   optional.String
	CountTotal optional.Int32
	LastId     optional.String
	Limit      optional.Int32
	Offset     optional.Int32
	Order      optional.Int32
}

func (a *FuturesApiService) GetMyTrades(ctx context.Context, settle string, localVarOptionals *GetMyTradesOpts) ([]MyFuturesTrade, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []MyFuturesTrade
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/my_trades"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Contract.IsSet() {
		localVarQueryParams.Add("contract", parameterToString(localVarOptionals.Contract.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Order.IsSet() {
		localVarQueryParams.Add("order", parameterToString(localVarOptionals.Order.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastId.IsSet() {
		localVarQueryParams.Add("last_id", parameterToString(localVarOptionals.LastId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CountTotal.IsSet() {
		localVarQueryParams.Add("count_total", parameterToString(localVarOptionals.CountTotal.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []MyFuturesTrade
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService Get single position
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param contract Futures contract
@return Position
*/
func (a *FuturesApiService) GetPosition(ctx context.Context, settle string, contract string) (Position, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Position
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/positions/{contract}"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contract"+"}", fmt.Sprintf("%v", contract), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Position
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService Get a single order
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param orderId ID returned on order successfully being created
@return FuturesPriceTriggeredOrder
*/
func (a *FuturesApiService) GetPriceTriggeredOrder(ctx context.Context, settle string, orderId string) (FuturesPriceTriggeredOrder, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FuturesPriceTriggeredOrder
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/price_orders/{order_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", fmt.Sprintf("%v", orderId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v FuturesPriceTriggeredOrder
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService Query account book
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param optional nil or *ListFuturesAccountBookOpts - Optional Parameters:
 * @param "Limit" (optional.Int32) -  Maximum number of record returned in one list
 * @param "From" (optional.Int32) -  Start timestamp
 * @param "To" (optional.Int32) -  End timestamp
 * @param "Type_" (optional.String) -  Changing Type: - dnw: Deposit & Withdraw - pnl: Profit & Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: POINT Deposit & Withdraw - point_fee: POINT Trading fee - point_refr: POINT Referrer rebate
@return []FuturesAccountBook
*/

type ListFuturesAccountBookOpts struct {
	Limit optional.Int32
	From  optional.Int32
	To    optional.Int32
	Type_ optional.String
}

func (a *FuturesApiService) ListFuturesAccountBook(ctx context.Context, settle string, localVarOptionals *ListFuturesAccountBookOpts) ([]FuturesAccountBook, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []FuturesAccountBook
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/account_book"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.From.IsSet() {
		localVarQueryParams.Add("from", parameterToString(localVarOptionals.From.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.To.IsSet() {
		localVarQueryParams.Add("to", parameterToString(localVarOptionals.To.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []FuturesAccountBook
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService Query futures account
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
@return FuturesAccount
*/
func (a *FuturesApiService) ListFuturesAccounts(ctx context.Context, settle string) (FuturesAccount, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FuturesAccount
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v FuturesAccount
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService Get futures candlesticks
Return specified contract candlesticks. If prefix &#x60;contract&#x60; with &#x60;mark_&#x60;, the contract&#39;s mark price candlesticks are returned; if prefix with &#x60;index_&#x60;, index price candlesticks will be returned.  Maximum of 2000 points are returned in one query. Be sure not to exceed the limit when specifying &#x60;from&#x60;, &#x60;to&#x60; and &#x60;interval&#x60;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param contract Futures contract
 * @param optional nil or *ListFuturesCandlesticksOpts - Optional Parameters:
 * @param "From" (optional.Float32) -  Start time of candlesticks, formatted in Unix timestamp in seconds. Default to`to - 100 * interval` if not specified
 * @param "To" (optional.Float32) -  End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time
 * @param "Limit" (optional.Int32) -  Maximum recent data points returned. `limit` is conflicted with `from` and `to`. If either `from` or `to` is specified, request will be rejected.
 * @param "Interval" (optional.String) -  Interval time between data points
@return []FuturesCandlestick
*/

type ListFuturesCandlesticksOpts struct {
	From     optional.Float32
	To       optional.Float32
	Limit    optional.Int32
	Interval optional.String
}

func (a *FuturesApiService) ListFuturesCandlesticks(ctx context.Context, settle string, contract string, localVarOptionals *ListFuturesCandlesticksOpts) ([]FuturesCandlestick, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []FuturesCandlestick
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/candlesticks"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("contract", parameterToString(contract, ""))
	if localVarOptionals != nil && localVarOptionals.From.IsSet() {
		localVarQueryParams.Add("from", parameterToString(localVarOptionals.From.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.To.IsSet() {
		localVarQueryParams.Add("to", parameterToString(localVarOptionals.To.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Interval.IsSet() {
		localVarQueryParams.Add("interval", parameterToString(localVarOptionals.Interval.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []FuturesCandlestick
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService List all futures contracts
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
@return []Contract
*/
func (a *FuturesApiService) ListFuturesContracts(ctx context.Context, settle string) ([]Contract, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Contract
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/contracts"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Contract
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService Funding rate history
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param contract Futures contract
 * @param optional nil or *ListFuturesFundingRateHistoryOpts - Optional Parameters:
 * @param "Limit" (optional.Int32) -  Maximum number of record returned in one list
@return []FundingRateRecord
*/

type ListFuturesFundingRateHistoryOpts struct {
	Limit optional.Int32
}

func (a *FuturesApiService) ListFuturesFundingRateHistory(ctx context.Context, settle string, contract string, localVarOptionals *ListFuturesFundingRateHistoryOpts) ([]FundingRateRecord, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []FundingRateRecord
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/funding_rate"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("contract", parameterToString(contract, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []FundingRateRecord
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService Futures insurance balance history
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param optional nil or *ListFuturesInsuranceLedgerOpts - Optional Parameters:
 * @param "Limit" (optional.Int32) -  Maximum number of record returned in one list
@return []InsuranceRecord
*/

type ListFuturesInsuranceLedgerOpts struct {
	Limit optional.Int32
}

func (a *FuturesApiService) ListFuturesInsuranceLedger(ctx context.Context, settle string, localVarOptionals *ListFuturesInsuranceLedgerOpts) ([]InsuranceRecord, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsuranceRecord
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/insurance"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsuranceRecord
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService Futures order book
Bids will be sorted by price from high to low, while asks sorted reversely
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param contract Futures contract
 * @param optional nil or *ListFuturesOrderBookOpts - Optional Parameters:
 * @param "Interval" (optional.String) -  Order depth. 0 means no aggregation is applied. default to 0
 * @param "Limit" (optional.Int32) -  Maximum number of order depth data in asks or bids
@return FuturesOrderBook
*/

type ListFuturesOrderBookOpts struct {
	Interval optional.String
	Limit    optional.Int32
}

func (a *FuturesApiService) ListFuturesOrderBook(ctx context.Context, settle string, contract string, localVarOptionals *ListFuturesOrderBookOpts) (FuturesOrderBook, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FuturesOrderBook
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/order_book"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("contract", parameterToString(contract, ""))
	if localVarOptionals != nil && localVarOptionals.Interval.IsSet() {
		localVarQueryParams.Add("interval", parameterToString(localVarOptionals.Interval.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v FuturesOrderBook
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService List futures orders
Zero-fill order cannot be retrieved 60 seconds after cancellation
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param contract Futures contract
 * @param status List orders based on status
 * @param optional nil or *ListFuturesOrdersOpts - Optional Parameters:
 * @param "Limit" (optional.Int32) -  Maximum number of record returned in one list
 * @param "Offset" (optional.Int32) -  List offset, starting from 0
 * @param "LastId" (optional.String) -  Specify list staring point using the `id` of last record in previous list-query results
 * @param "CountTotal" (optional.Int32) -  Whether to return total number matched. Default to 0(no return)
@return []FuturesOrder
*/

type ListFuturesOrdersOpts struct {
	Limit      optional.Int32
	Offset     optional.Int32
	LastId     optional.String
	CountTotal optional.Int32
}

func (a *FuturesApiService) ListFuturesOrders(ctx context.Context, settle string, contract string, status string, localVarOptionals *ListFuturesOrdersOpts) ([]FuturesOrder, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []FuturesOrder
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/orders"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("contract", parameterToString(contract, ""))
	localVarQueryParams.Add("status", parameterToString(status, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastId.IsSet() {
		localVarQueryParams.Add("last_id", parameterToString(localVarOptionals.LastId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CountTotal.IsSet() {
		localVarQueryParams.Add("count_total", parameterToString(localVarOptionals.CountTotal.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []FuturesOrder
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService List futures tickers
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param optional nil or *ListFuturesTickersOpts - Optional Parameters:
 * @param "Contract" (optional.String) -  Futures contract, return related data only if specified
@return []FuturesTicker
*/

type ListFuturesTickersOpts struct {
	Contract optional.String
}

func (a *FuturesApiService) ListFuturesTickers(ctx context.Context, settle string, localVarOptionals *ListFuturesTickersOpts) ([]FuturesTicker, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []FuturesTicker
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/tickers"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Contract.IsSet() {
		localVarQueryParams.Add("contract", parameterToString(localVarOptionals.Contract.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []FuturesTicker
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService Futures trading history
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param contract Futures contract
 * @param optional nil or *ListFuturesTradesOpts - Optional Parameters:
 * @param "Limit" (optional.Int32) -  Maximum number of record returned in one list
 * @param "LastId" (optional.String) -  Specify list staring point using the id of last record in previous list-query results  This parameter is deprecated. Use `from` and `to` instead to limit time range
 * @param "From" (optional.Float32) -  Specify starting time in Unix seconds. If not specified, `to` and `limit` will be used to limit response items. If items between `from` and `to` are more than `limit`, only `limit` number will be returned.
 * @param "To" (optional.Float32) -  Specify end time in Unix seconds, default to current time
@return []FuturesTrade
*/

type ListFuturesTradesOpts struct {
	Limit  optional.Int32
	LastId optional.String
	From   optional.Float32
	To     optional.Float32
}

func (a *FuturesApiService) ListFuturesTrades(ctx context.Context, settle string, contract string, localVarOptionals *ListFuturesTradesOpts) ([]FuturesTrade, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []FuturesTrade
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/trades"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("contract", parameterToString(contract, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastId.IsSet() {
		localVarQueryParams.Add("last_id", parameterToString(localVarOptionals.LastId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.From.IsSet() {
		localVarQueryParams.Add("from", parameterToString(localVarOptionals.From.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.To.IsSet() {
		localVarQueryParams.Add("to", parameterToString(localVarOptionals.To.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []FuturesTrade
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService List liquidation history
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param optional nil or *ListLiquidatesOpts - Optional Parameters:
 * @param "Contract" (optional.String) -  Futures contract, return related data only if specified
 * @param "Limit" (optional.Int32) -  Maximum number of record returned in one list
 * @param "At" (optional.Int32) -  Specify a liquidation timestamp
@return []FuturesLiquidate
*/

type ListLiquidatesOpts struct {
	Contract optional.String
	Limit    optional.Int32
	At       optional.Int32
}

func (a *FuturesApiService) ListLiquidates(ctx context.Context, settle string, localVarOptionals *ListLiquidatesOpts) ([]FuturesLiquidate, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []FuturesLiquidate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/liquidates"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Contract.IsSet() {
		localVarQueryParams.Add("contract", parameterToString(localVarOptionals.Contract.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.At.IsSet() {
		localVarQueryParams.Add("at", parameterToString(localVarOptionals.At.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []FuturesLiquidate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService List position close history
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param optional nil or *ListPositionCloseOpts - Optional Parameters:
 * @param "Contract" (optional.String) -  Futures contract, return related data only if specified
 * @param "Limit" (optional.Int32) -  Maximum number of record returned in one list
@return []PositionClose
*/

type ListPositionCloseOpts struct {
	Contract optional.String
	Limit    optional.Int32
}

func (a *FuturesApiService) ListPositionClose(ctx context.Context, settle string, localVarOptionals *ListPositionCloseOpts) ([]PositionClose, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []PositionClose
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/position_close"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Contract.IsSet() {
		localVarQueryParams.Add("contract", parameterToString(localVarOptionals.Contract.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []PositionClose
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService List all positions of a user
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
@return []Position
*/
func (a *FuturesApiService) ListPositions(ctx context.Context, settle string) ([]Position, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Position
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/positions"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Position
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService List all auto orders
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param status List orders based on status
 * @param optional nil or *ListPriceTriggeredOrdersOpts - Optional Parameters:
 * @param "Contract" (optional.String) -  Futures contract, return related data only if specified
 * @param "Limit" (optional.Int32) -  Maximum number of record returned in one list
 * @param "Offset" (optional.Int32) -  List offset, starting from 0
@return []FuturesPriceTriggeredOrder
*/

type ListPriceTriggeredOrdersOpts struct {
	Contract optional.String
	Limit    optional.Int32
	Offset   optional.Int32
}

func (a *FuturesApiService) ListPriceTriggeredOrders(ctx context.Context, settle string, status string, localVarOptionals *ListPriceTriggeredOrdersOpts) ([]FuturesPriceTriggeredOrder, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []FuturesPriceTriggeredOrder
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/price_orders"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("status", parameterToString(status, ""))
	if localVarOptionals != nil && localVarOptionals.Contract.IsSet() {
		localVarQueryParams.Add("contract", parameterToString(localVarOptionals.Contract.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []FuturesPriceTriggeredOrder
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService Update position leverage
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param contract Futures contract
 * @param leverage New position leverage
@return Position
*/
func (a *FuturesApiService) UpdatePositionLeverage(ctx context.Context, settle string, contract string, leverage string) (Position, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Position
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/positions/{contract}/leverage"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contract"+"}", fmt.Sprintf("%v", contract), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("leverage", parameterToString(leverage, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Position
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService Update position margin
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param contract Futures contract
 * @param change Margin change. Use positive number to increase margin, negative number otherwise.
@return Position
*/
func (a *FuturesApiService) UpdatePositionMargin(ctx context.Context, settle string, contract string, change string) (Position, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Position
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/positions/{contract}/margin"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contract"+"}", fmt.Sprintf("%v", contract), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("change", parameterToString(change, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Position
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FuturesApiService Update position risk limit
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param settle Settle currency
 * @param contract Futures contract
 * @param riskLimit New position risk limit
@return Position
*/
func (a *FuturesApiService) UpdatePositionRiskLimit(ctx context.Context, settle string, contract string, riskLimit string) (Position, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Position
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/futures/{settle}/positions/{contract}/risk_limit"
	localVarPath = strings.Replace(localVarPath, "{"+"settle"+"}", fmt.Sprintf("%v", settle), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contract"+"}", fmt.Sprintf("%v", contract), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("risk_limit", parameterToString(riskLimit, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := make([]string, 0)

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams,
		localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes, true)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	_ = localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Position
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, errors.New(newErr.Error())
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
